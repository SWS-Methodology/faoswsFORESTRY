[
["faoswsForestryAggregation.html", "Chapter 1 The faoswsForestryAggregation module 1.1 Aims 1.2 Reads in the input data set and data tables 1.3 Gets regional aggregation 1.4 Gets Forestry commodity aggregation 1.5 Get Unit values 1.6 Get back the original flags 1.7 Convert FAOSTAT regions to SWS regions 1.8 Binding national and regional data 1.9 Compare before and after aggregations 1.10 Save data in the SWS shared drive and in the SWS database", " Chapter 1 The faoswsForestryAggregation module 1.1 Aims The faoswsForestryAggregation module essentially aims at working as a validation tool which is used by the the technical unit to check the effects of data changes in the forestry_prod_trade data set on geographical and commodity aggregations. 1.2 Reads in the input data set and data tables The module uses the forestry_prod_agg dataset as input. According to the technical unit, they will be constantly changing this dataset throughout the data cycle, specially when new data come in or the officers decide to make changes based on their domain knowledge. suppressMessages({ library(faosws) library(faoswsUtil) library(faoswsFlag) library(data.table) library(dplyr) library(tidyr) library(stringr) }) if(CheckDebug()){ library(faoswsModules) SETTINGS = ReadSettings(&quot;~./github/faoswsForestryProduction/sws.yml&quot;) Sys.setenv(&quot;R_SWS_SHARE_PATH&quot; = SETTINGS[[&quot;share&quot;]]) R_SWS_SHARE_PATH = SETTINGS[[&quot;share&quot;]] SetClientFiles(SETTINGS[[&quot;certdir&quot;]]) GetTestEnvironment(baseUrl = SETTINGS[[&quot;server&quot;]], token = SETTINGS[[&quot;token&quot;]]) } if (!CheckDebug()) { R_SWS_SHARE_PATH = Sys.getenv(&quot;R_SWS_SHARE_PATH&quot;) } ### --- READ DATATABLES ----- agg_tree &lt;- ReadDatatable(&#39;forestry_aggregate_composition&#39;) fo_aggregate &lt;- agg_tree[, lapply(.SD, as.integer)] fo_agg &lt;- copy(fo_aggregate) list_items &lt;- unique(c(unique(fo_aggregate$item_code), unique(fo_aggregate$item_group_code))) data_element &lt;- ReadDatatable(&#39;forestry_domain_elements&#39;) list_elements &lt;- c(unique(as.integer(data_element$element_code)), 5910, 5610) # For regional aggregation fstom49 &lt;- ReadDatatable(&#39;m49_fs_iso_mapping&#39;) group_area &lt;- fstom49[, .(group_area_code, group_area_name)] setnames(group_area, c(&quot;group_area_code&quot;, &quot;group_area_name&quot;), c(&quot;fs_area_code&quot;, &quot;fs_area_name&quot;)) country_area &lt;- fstom49[, .(fs_area_code, fs_area_name)] country_regions_fs &lt;- unique(rbind(country_area, group_area)) setnames(country_regions_fs,c(&quot;fs_area_code&quot;, &quot;fs_area_name&quot;), c(&quot;AreaCode&quot;, &quot;AreaName&quot;)) # Get a table to mapping faostat regional codes to M49 regional codes fs_m49_reg &lt;- ReadDatatable(&#39;fs_m49_regions&#39;) # GLOBAL VARIABLES ---- # Get all elements but unit values. sum_elements &lt;- as.character(c(5510, 5516, 5610, 5616, 5622, 5910, 5916, 5922)) # creat an object storing columns that never change. colalways &lt;- c(&quot;geographicAreaM49&quot;, &quot;measuredItemForestry&quot;, &quot;measuredElement&quot;, &quot;timePointYears&quot;) # all aggregates group_code_list_all &lt;- as.character(unique(fo_agg$item_group_code)) # major SWS regions major_regions &lt;- c(&quot;953&quot;, &quot;933&quot;, &quot;1125&quot;, &quot;913&quot;, &quot;914&quot;, &quot;915&quot;, &quot;1056&quot;, &quot;952&quot;, &quot;934&quot;) bench &lt;- data_raw[, mget(c(colalways, &quot;Value&quot;))] ## -- READ IN INPUT DATA ---- imputKey &lt;- DatasetKey( domain = &quot;Forestry&quot;, dataset = &quot;forestry_prod_trade&quot;, dimensions = list( Dimension(name = &quot;geographicAreaM49&quot;, keys = GetCodeList(&#39;Forestry&#39;, &quot;forestry_prod_trade&quot;, &#39;geographicAreaM49&#39;)[type == &#39;country&#39;, code]), Dimension(name = &quot;measuredItemForestry&quot;, keys = as.character(list_items)), Dimension(name = &quot;measuredElement&quot;, keys = as.character(list_elements)), Dimension(name = &quot;timePointYears&quot;, keys = as.character(1961:substring(Sys.time(), 1, 4))) ) ) data_raw &lt;- GetData(imputKey, flags = TRUE) data_input &lt;- copy(data_raw) 1.3 Gets regional aggregation After reading in the input dataset, the module geographically aggregates the primary commodities based on FAOSTAT - UNSD M49 mapping. Please, for a full representation of this table consult either the introductory session (data table) or this link. # PERFORMING REGIONAL AGGREGATION ---- GetRegionalAggregation &lt;- function(data) { data_input01 &lt;- copy(data) if (!is.data.table(data_input01)) data_input01 &lt;- as.data.table(data_input01) data_input01 &lt;- data_input01[measuredElement %in% sum_elements] to_region &lt;- unique(fstom49[, list(group_area_code, m49)]) setnames(to_region, &#39;m49&#39;, &#39;geographicAreaM49&#39;) m1 &lt;- merge(data_input01, to_region, by = &quot;geographicAreaM49&quot;, all.x = TRUE, allow.cartesian = TRUE) m1_agg &lt;- m1[, list(Val = sum(Value, na.rm = TRUE)), by = list(group_area_code, measuredItemForestry, measuredElement, timePointYears)] setnames(m1_agg, c(&quot;group_area_code&quot;, &quot;Val&quot;), c(&quot;geographicAreaM49&quot;, &quot;Value&quot;)) data_input_c &lt;- m1_agg data_input_c$flagObservationStatus &lt;- &quot;E&quot; #&#39; **Aggregates** data_input_c$flagMethod &lt;- &quot;s&quot; #&#39; ** Aggregates** data_input_c &lt;- unique(data_input_c, by = colalways) return(data_input_c) } data_input_reg &lt;- GetRegionalAggregation(data = data_input) data_input_reg &lt;- data_input_reg[!is.na(geographicAreaM49)][order(geographicAreaM49, measuredItemForestry, measuredElement, timePointYears)] data_input_reg &lt;- unique(data_input_reg, by = colalways) 1.4 Gets Forestry commodity aggregation Once a data set with regional aggregate is ready, the module moves to producing commodity aggregations at the national and geographical levels. Before the aggregations, the modules filters out all commodity groups and analytical elements (Export and Import unit values) so that they can be recalculated. The technical unit requested that the aggregates should be recalculated EVERY time the module runs. Since there is an interplay between commodity groups, the current Forestry system carries the aggregation in tandem, with four commodity groups being aggregated first and then rest of aggregates. The forestry Aggregation module applies the same logic. Table 1.1: First commodity groups to be calculated by the faoswsForestryAggregation module CommodityGroup CommodityGroupName CommodityCode CommodityName 1656 Chemical wood pulp 1660 Chemical wood pulp, sulphite, unbleached 1656 Chemical wood pulp 1661 Chemical wood pulp, sulphite, bleached 1656 Chemical wood pulp 1662 Chemical wood pulp, sulphate, unbleached 1656 Chemical wood pulp 1663 Chemical wood pulp, sulphate, bleached 1674 Printing and writing papers 1612 Printing and writing papers, uncoated, wood containing 1674 Printing and writing papers 1615 Printing and writing papers, uncoated, wood free 1674 Printing and writing papers 1616 Printing and writing papers, coated 1675 Other paper and paperboard 1676 Household and sanitary papers 1675 Other paper and paperboard 1681 Wrapping and packaging paper and paperboard 1675 Other paper and paperboard 1683 Other paper and paperboard n.e.s. 1681 Wrapping and packaging paper and paperboard 1617 Case materials 1681 Wrapping and packaging paper and paperboard 1618 Cartonboard 1681 Wrapping and packaging paper and paperboard 1621 Wrapping papers 1681 Wrapping and packaging paper and paperboard 1622 Other papers mainly for packaging The function GetAggs applies the aggregation logic to both national and regional data sets. GetAggs &lt;- function(data){ d &lt;- copy(data) if(!is.data.table(d)) d &lt;- as.data.table(d) d &lt;- d[measuredElement %in% as.character(sum_elements)] tree &lt;- copy(fo_aggregate) agg_order &lt;- unique(c(tree$first_aggregates[!is.na(tree$first_aggregates)], tree$item_group_code[!tree$item_group_code %in% tree$first_aggregates])) agg_order &lt;- intersect(agg_order, unique(d$measuredItemForestry)) rawinput &lt;- d[measuredElement %in% sum_elements] rawwide &lt;- dcast(rawinput, geographicAreaM49 + measuredElement + timePointYears ~ measuredItemForestry, value.var = &quot;Value&quot;) data_new &lt;- as.data.table(copy(rawwide)) for (agg in seq_along(agg_order)) { group &lt;- as.character(agg_order[agg]) all_elements &lt;- as.character(unique(tree[item_group_code == group][, c(item_group_code, item_code)])) comps &lt;- as.character(all_elements[!all_elements %in% group]) data_new$agg_old &lt;- data_new[[group]] data_new[, agg_new0 := rowSums(.SD, na.rm = FALSE), .SDcols = comps] data_new[, agg_new1 := rowSums(.SD, na.rm = TRUE), .SDcols = comps] data_new[, agg_new1 := ifelse(is.na(agg_new0) &amp; agg_new1 == 0, NA_real_, agg_new1)] data_new[, agg_new := agg_new1] data_new[, agg_new := ifelse(is.na(agg_new) &amp; !is.na(agg_old), agg_old , agg_new)] data_new[, c(&quot;agg_old&quot;, &quot;agg_new0&quot;, &quot;agg_new1&quot;, group) := NULL] setnames(data_new, &quot;agg_new&quot;, group) } df &lt;- melt(data_new, 1:3, variable.name = &quot;measuredItemForestry&quot;, value.name = &quot;Value&quot;) df &lt;- df[, list(geographicAreaM49, measuredItemForestry, measuredElement, timePointYears, Value)] df &lt;- df[, lapply(.SD, as.character)] df$Value &lt;- as.numeric(df$Value) df &lt;- df[!is.na(Value)] return(df) } pivot_data_national &lt;- GetAggs(data = data_input) pivot_data_regional &lt;- GetAggs(data = data_input_reg) 1.5 Get Unit values Once the import and export are calculated for values and quantity, the unit price, which is the quotient between values and quantity, can be easily for both primary and group commodities at the national and regional levels. The R function for accomplishing this is GetUnitValues(). # Getting UNIT values GetUnitValues &lt;- function(data) { d &lt;- copy(data) if (!is.data.table(d) d &lt;- as.data.table(d) wide_df &lt;- dcast(d, geographicAreaM49 + measuredItemForestry + timePointYears ~ measuredElement, value.var = &quot;Value&quot;) wide_df[, `:=` (`5636` = (`5622`/`5616`)*1000, `5936` = (`5922`/`5916`)*1000, `5630` = 1000*(`5622`/`5610`),`5930` = 1000*(`5922`/`5910`))] pivot_df &lt;- melt(wide_df, id.vars = 1:3, variable.name = &quot;measuredElement&quot;, value.name = &quot;Value&quot;) pivot_df &lt;- pivot_df[!is.na(Value) &amp; !is.infinite(Value)][, list(geographicAreaM49, measuredItemForestry, measuredElement, timePointYears, Value)] pivot_df &lt;- pivot_df[measuredElement %in% c(&quot;5630&quot;, &quot;5636&quot;, &quot;5930&quot;, &quot;5936&quot;)] pivot_bind &lt;- rbind(d, pivot_df)[order(geographicAreaM49, measuredItemForestry, measuredElement, timePointYears)] return(pivot_bind) } pivot_national_unit &lt;- GetUnitValues(data = pivot_data_national) pivot_regional_unit &lt;- GetUnitValues(data = pivot_data_regional) 1.6 Get back the original flags With unit values already in the data sets (national and regional), the last step is to recovery the flags from the original input. Data records added during the processing come either from geographic or commodity aggregation. Therefore, these records have “E” (Aggregation) as flagObservationStatus and “s” (summation) as flagMethod. The R function GetFlags() does the work. # Recoverying original flags GetFlags &lt;- function(data) { d &lt;- copy(data) if (!is.data.table(d) d &lt;- as.data.table(d) lgt &lt;- &quot;5000&quot; %in% unique(d$geographicAreaM49) if (lgt) { d[, flagObservationStatus := &quot;E&quot;] d[, flagMethod := &quot;s&quot;] d[, flagMethod := ifelse(!(measuredElement %in% sum_elements), &quot;i&quot;, flagMethod)] } else { d &lt;- data_raw[d, on = colalways] d$Value_new &lt;- d$i.Value d[, flagObservationStatus := ifelse(measuredItemForestry %in% group_code_list_all, &quot;E&quot;, flagObservationStatus)] d[, flagMethod := ifelse(measuredItemForestry %in% group_code_list_all, &quot;s&quot;, flagMethod)] d[, flagMethod := ifelse(!(measuredElement %in% sum_elements), &quot;i&quot;, flagMethod)] d &lt;- d[, list(geographicAreaM49, measuredItemForestry,measuredElement,timePointYears,Value_new,flagObservationStatus, flagMethod)] setnames(d, &quot;Value_new&quot;, &quot;Value&quot;) } return(d) } pivot_national_flags &lt;- GetFlags(data = pivot_national_unit) pivot_regional_flags &lt;- GetFlags(data = pivot_regional_unit) 1.7 Convert FAOSTAT regions to SWS regions The processed regional data set uses FAOSTAT codes for regions. To be able to save the results in the SWS, regions must be converted to SWS regional codes compatible with the geographicAreaM49 in the forestry_prod_trade_agg dataset. For this, the module uses the following function. fs2m49_reg &lt;- function(data){ df &lt;- copy(data) n_df &lt;- names(df) reg_code &lt;- c(unique(df$geographicAreaM49)[unique(as.integer(df$geographicAreaM49)) &gt;= 5000], 420, 429) df_reg &lt;- df[geographicAreaM49 %in% reg_code] fs_m49_regg &lt;- fs_m49_reg[!is.na(m49_reg)] dmerged &lt;- merge(df_reg, fs_m49_regg, by.x = &quot;geographicAreaM49&quot;, by.y = &quot;fs_reg&quot;) df_merged &lt;- dmerged[, geographicAreaM49 := NULL] setnames(df_merged, &quot;m49_reg&quot;, &quot;geographicAreaM49&quot;) df_merged &lt;- df_merged[, mget(n_df)] df_final_ &lt;- df_merged[geographicAreaM49 %in% major_regions][order(geographicAreaM49, measuredItemForestry, measuredItemForestry)] return(df_final_) } pivot_regional_flags_sws &lt;- fs2m49_reg(data = pivot_regional_flags) 1.8 Binding national and regional data Binding national and regional data sets. data_all &lt;- rbind(pivot_national_flags, pivot_regional_flags_sws) data_all &lt;- data_all[, Value := round(Value, 1)][order(geographicAreaM49, measuredItemForestry, measuredItemForestry)] data_all &lt;- data_all[, lapply(.SD, as.character)] data_all$Value &lt;- as.numeric(data_all$Value) data_all &lt;- data_all[complete.cases(data_all), ] 1.9 Compare before and after aggregations As a validation tool, the faoswsForestryAggregation module also needs to return what has changed from the input dataset. The module flags values where the absolute difference between the input dataset and the aggregate dataset is higher than one. This comparison is carried on the code snippet below. comp &lt;- data_raw[data_all, on = colalways][, `:=` (diff = round(abs(Value - i.Value), 1))][diff &gt; 0.1] comp &lt;- nameData(&#39;forestry&#39;, &quot;forestry_prod_trade&quot;, comp) setnames(comp, c(&quot;i.Value&quot;, &quot;i.flagObservationStatus&quot;, &quot;i.flagMethod&quot;), c(&quot;new_Value&quot;, &quot;new_flagObservationStatus&quot;, &quot;new_flagMethod&quot;)) 1.10 Save data in the SWS shared drive and in the SWS database The data with primary and grouped commodities at the national and regional levels can be also accessed by the user as a csv file in the SWS shared drive. The full data is saved in the folder full_results/full_results.csv, whereas the comparison csv file is saved in the folder comparisons/diff_values.csv. Every time the module runs these files are updated. # Saving in the SWS shared drive write.csv(data_all, file.path(Sys.getenv(&#39;R_SWS_SHARE_PATH&#39;), &#39;ForestryProdAndTrade/output/faoswsForestryAggregation/full_results&#39;, &#39;full_results.csv&#39;), row.names = FALSE) write.csv(comp, file.path(Sys.getenv(&#39;R_SWS_SHARE_PATH&#39;), &#39;ForestryProdAndTrade/output/faoswsForestryAggregation/comparisons&#39;, &#39;diff_values.csv&#39;), row.names = FALSE) # Saving in the SWS database stats &lt;- SaveData(&quot;forestry&quot;, dataset = swsContext.datasets[[1]]@dataset, data = data_all, chunkSize = 50000, waitTimeout = 2000000) print(paste(&#39;FORESTRY AGGREGATION IS SAVED IN THE SESSION &#39;, Sys.time())) paste0(&quot;ForestryAggregation module ran successfully!!!&quot;, stats$inserted, &quot; observations written, &quot;, stats$ignored, &quot; weren&#39;t updated, &quot;, stats$discarded, &quot; had problems.&quot;) "],
["runnig-the-module-.html", "Runnig the module.", " Runnig the module. The steps decrebide below are pointing the users (FOA unit) to the right direction for running the module sucessfully. Login to SWS QA. Figure 1.1: SWS QA login. Run a new query. Run the query on the forestry_prod_trade_agg data set. Figure 1.2: Run the query. Select faoswsForestryAggregation plugin. Figure 1.3: SWS QA login. Select faoswsForestryAggregation and run plugin. Figure 1.4: Select and run the plugin. Wait for results. Figure 1.5: Waiting for results. Check results on the session. The data set is saved directly in the database as forestry_prod_trade_agg data set. The user can check the results on the session. Figure 1.6: Aggregates on the session. "]
]
